# -*- coding: utf-8 -*-
"""Image_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bL4oIJ6a2GG0M7WSvvLwpcuCG5Ws4ub7
"""

from google.colab import drive
drive.mount('/content/drive')

"""Importing"""

!pip install ipyplot

import tensorflow as tf
import numpy as np
import cv2
from matplotlib import pyplot as plt
from tqdm import tqdm
import os
import random
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.utils import to_categorical
from tensorflow.keras import layers
import math
import ipyplot
from tensorflow import keras
from sklearn.utils import shuffle
from tensorflow.keras.models import *
from tensorflow.keras.layers import *
from tensorflow.keras.optimizers import *
from tensorflow.keras.losses import *
from sklearn.metrics import f1_score

def decaying_cosine_annealing_scheduler(epoch):
    """
        A step rate scheduler for setting the learning rate for each epoch.
        :param epoch: current epoch
        :return: learning rate for current epoch
        """
    learning_rate_min = 1e-6
    original_learning_rate_max = 1e-3
    original_cycle_length = 15
    epochs_per_cycle = original_cycle_length-(int(epoch/original_cycle_length))
    learning_rate_max = original_learning_rate_max/((int(epoch/original_cycle_length))+1)
    #print(learning_rate_max,learning_rate_min, epoch, epochs_per_cycle)

    return learning_rate_min + (learning_rate_max - learning_rate_min) * \
           (1 + math.cos(math.pi * (epoch % epochs_per_cycle) / epochs_per_cycle)) / 2

"""Converting to NPY"""

X=[]
Z=[]
IMG_SIZE=256

ate = '/content/drive/MyDrive/Damta/For Project/Classification/Validation/1. ATELECTASIS'
ple = '/content/drive/MyDrive/Damta/For Project/Classification/Validation/10. PLEURAL EFFUSION'
car= '/content/drive/MyDrive/Damta/For Project/Classification/Validation/2. CARDIOMEGALY'
con = '/content/drive/MyDrive/Damta/For Project/Classification/Validation/3. CONSOLIDATION'
nof = '/content/drive/MyDrive/Damta/For Project/Classification/Validation/9. NO FINDING'
ede = '/content/drive/MyDrive/Damta/For Project/Classification/Validation/4. EDEMA'


def assign_label(img,type):
    return type


def make_train_data(type, DIR):
    for img in tqdm(os.listdir(DIR)):
        label = assign_label(img, type)
        path = os.path.join(DIR, img)
        img = cv2.imread(path, cv2.IMREAD_COLOR)
        img = cv2.resize(img, (IMG_SIZE, IMG_SIZE))

        X.append(np.array(img))
        Z.append(str(label))
make_train_data('ATELECTASIS',ate)
make_train_data('CARDIOMEGALY',car)
make_train_data('CONSOLIDATION',con)
make_train_data('EDEMA',ede)
make_train_data('NO FINDING',nof)
make_train_data('PLEURAL EFFUSION',ple)
le=LabelEncoder()
Y=le.fit_transform(Z)
Y=to_categorical(Y,6)
X=np.array(X)

"""Saving NPYconverted files"""

np.save('val_img',X)
np.save('val_label',Y)

training_img_path = '/content/train_img.npy'
training_labels_path = '/content/train_label.npy'
validating_img_path = '/content/val_img.npy'
validating_labels_path = '/content/val_label.npy'


train_img, train_label, val_img, val_label = np.load(training_img_path), np.load(training_labels_path), np.load(validating_img_path), np.load(validating_labels_path) 

print('Shape of training images and training lables is: ', train_img.shape, ',', train_img.shape)
print('Shape of Validating images and Validating lables is: ', val_img.shape, ',', val_label.shape)

ipyplot.plot_images(train_img[:,:,:,::-1], max_images=10, img_width=150)
print([list(x) for x in train_label[0:10,:]], sep = '     ')

ipyplot.plot_images(val_img[:,:,:,::-1], max_images=10, img_width=150)
print([list(x) for x in val_label[0:10,:]], sep = '      ')

train_img, train_label = shuffle(train_img,train_label)

model = Sequential()
#Creating the model
model = Sequential()
model.add(Conv2D(filters = 8, kernel_size = (5,5),padding = 'Same',activation ='relu', input_shape = (256,256,3)))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.2))


model.add(Conv2D(filters = 16, kernel_size = (3,3),padding = 'Same',activation ='relu'))
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))
model.add(Dropout(0.2))
 

model.add(Conv2D(filters =32, kernel_size = (3,3),padding = 'Same',activation ='relu'))
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))
model.add(Dropout(0.2))

model.add(Conv2D(filters = 64, kernel_size = (3,3),padding = 'Same',activation ='relu'))
model.add(MaxPooling2D(pool_size=(2,2), strides=(2,2)))
model.add(Dropout(0.2))

model.add(Flatten())
model.add(Dense(128))
model.add(Activation('relu'))
model.add(Dense(64))
model.add(Activation('relu'))
model.add(Dense(6, activation = "softmax"))
opt = Adam(lr=0.001)
model.compile(optimizer=opt, loss=keras.losses.categorical_crossentropy, metrics=['accuracy'])
model.summary()

major_revision, minor_revision = 1,1
model_save_path = '/content/drive/MyDrive/Models'
log_save_path = '/content/drive/MyDrive/Logs'

file_path = os.path.join(model_save_path, 'm%i-%i.h5' % (major_revision, minor_revision))
checkpoints_callback = tf.keras.callbacks.ModelCheckpoint(file_path, monitor= 'val_categorical_accuracy', verbose = 1, mode='max', save_best_only=True, save_freq='epoch')
    
learning_rate_callback = tf.keras.callbacks.LearningRateScheduler(decaying_cosine_annealing_scheduler, verbose=True)
    
file = open(os.path.join(log_save_path, 'log-%i-%i.txt' % (major_revision, minor_revision)),'a+')
    
text_logging_callback = tf.keras.callbacks.LambdaCallback(
on_epoch_end=lambda epoch, logs: file.write('####EPOCH %i\n' % (epoch + 1) + '#### VALIDATION ACCURACY =%.5f \n' % logs['val_categorical_accuracy'])
)
    
my_callbacks = [checkpoints_callback, learning_rate_callback, text_logging_callback]

epochs = 10

print('Training...')

model_history = model.fit(x=train_img, y=train_label , epochs=epochs, validation_split = 0.1)


file.close()

my_predictions = model.predict(val_img)
print(my_predictions.shape)


cmd = ConfusionMatrixDisplay((confusion_matrix(list(np.argmax(val_label, axis=1)), list(np.argmax(my_predictions, axis=1)))), display_labels=['ATELECTASIS','CARDIOMEGALY','CONSOLIDATION','EDEMA','NO FINDING','PLEURAL EFFUSION'])
cmd.plot()
plt.show()